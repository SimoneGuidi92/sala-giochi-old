{"ast":null,"code":"// // import { log } from 'console';\n// // import { Observable, fromEvent } from 'rxjs';\n// import { map } from 'rxjs/operators';\n// import { map, filter, scan, switchMap, startWith, distinctUntilChanged, share, withLatestFrom, skip, tap, takeWhile } from 'rxjs/operators';\n// import { Observable, Subject, asapScheduler, pipe, of, from,\n//   interval, merge, fromEvent, BehaviorSubject, generate, combineLatest, animationFrame } from 'rxjs'\n// // import 'rxjs/Rx';\n// // import 'rxjs/add/operator/map';\n// import { DIRECTIONS, FPS, INITIAL_DIRECTION, POINTS_PER_APPLE, Point2D, SNAKE_LENGTH, SPEED, createCanvasElement } from 'src/assets/const-canvas/base-prop-func';\nimport { BehaviorSubject } from '../../../../assets/imports/rxjs';\nimport { DIRECTIONS, SPEED, SNAKE_LENGTH, FPS, POINTS_PER_APPLE } from '../../../../assets/imports/constants';\nimport { Key } from '../../../../assets/imports/types';\nimport { createCanvasElement, renderScene, renderGameOver } from '../../../../assets/imports/canvas';\nimport { isGameOver, nextDirection, move, eat, generateSnake, generateApples } from '../../../../assets/imports/utils';\nimport { distinctUntilChanged, filter, fromEvent, map, interval, scan, startWith, share, withLatestFrom, skip, tap, combineLatest, animationFrame, takeWhile } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nconst _c0 = [\"snakeDiv\"];\nexport let GameComponent = /*#__PURE__*/(() => {\n  class GameComponent {\n    constructor() {\n      this.canvas = null;\n      this.score = 0;\n    }\n\n    ngOnDestroy() {\n      // removeCanvasElement();\n      this.canvas.remove();\n    }\n\n    ngOnInit() {\n      // window.location.reload();\n      // throw new Error('Method not implemented.');\n\n      /**\r\n      * Crea un nuovo elemento canvas e lo appende alla pagina\r\n      */\n      this.canvas = createCanvasElement();\n      let divElement = this.snakeDivTs.nativeElement;\n      divElement.appendChild(this.canvas); // let divSnake = document.getElementById('snake-content');\n      //   if(divSnake) {\n      //     divSnake.appendChild(this.canvas);\n      //     divSnake.style.backgroundColor = '#F2F7FC';\n      //     divSnake.style.width = '100%';\n      //     divSnake.style.height = '100%';\n      //   }\n\n      let ctx = this.canvas.getContext('2d'); // document.body.appendChild(this.canvas);\n\n      /**\r\n       * Valore iniziale della direzione del serpente\r\n       */\n\n      const INITIAL_DIRECTION = DIRECTIONS[Key.RIGHT];\n      /**\r\n       * Determina la velocita del serpente\r\n       */\n\n      let ticks$ = interval(SPEED);\n      /**\r\n       * Traccia interazioni generali dell'utente con la pagina\r\n       */\n\n      let click$ = fromEvent(document, 'click');\n      let keydown$ = fromEvent(document, 'keydown');\n      /**\r\n       * Cambio di direzione del serpente controllando l'ultima freccia utilizzata dall'utente\r\n       */\n\n      let direction$ = keydown$.pipe(map(event => DIRECTIONS[event.keyCode]), filter(direction => !!direction), scan(nextDirection), startWith(INITIAL_DIRECTION), distinctUntilChanged());\n      /**\r\n       * Meccanismo di trasmissione utilizzato per notificare agli abbonati le collisioni tra il serpente e le mele\r\n       */\n\n      let length$ = new BehaviorSubject(SNAKE_LENGTH);\n      /**\r\n       * Accumula la lunghezza del serpente\r\n       */\n\n      let snakeLength$ = length$.pipe(scan((step, snakeLength) => snakeLength + step), share());\n      /**\r\n       * Score dell'utente\r\n       */\n      // let score$ = snakeLength$.pipe(\n      //   startWith(0),\n      //   scan((score, _) => score + POINTS_PER_APPLE)\n      // );\n\n      /**\r\n       * Accumula un array di body segments. Ogni segmento è rappresentato come una cella sulla griglia\r\n       */\n\n      let snake$ = ticks$.pipe(withLatestFrom(direction$, snakeLength$, (_, direction, snakeLength) => [direction, snakeLength]), scan(move, generateSnake()), share());\n      /**\r\n       * Lista di mele\r\n       */\n\n      let apples$ = snake$.pipe(scan(eat, generateApples()), distinctUntilChanged(), share());\n      /**\r\n       * Utilizzato per trasmettere le collisioni per aggiornare il punteggio e aggiungere un nuovo segmento al serpente\r\n       */\n\n      let appleEaten$ = apples$.pipe(skip(1), tap(() => length$.next(POINTS_PER_APPLE))).subscribe(() => {\n        this.score = this.score + 1;\n      });\n      /**\r\n       * Logica di base del gioco che restituisce un Osservabile della scena. Questo sarà per renderizzare il gioco sulla tela mentre si svolge\r\n       */\n      // let scene$ = combineLatest(snake$, apples$, score$, (snake, apples, score) => ({ snake, apples, score }));\n\n      let scene$ = combineLatest(snake$, apples$, (snake, apples) => ({\n        snake,\n        apples\n      }));\n      /**\r\n       * Questo flusso si occupa di rendere il gioco mantenendo 60 FPS\r\n       */\n\n      let game$ = interval(1000 / FPS, animationFrame).pipe(withLatestFrom(scene$, (_, scene) => scene), takeWhile(scene => !isGameOver(scene))).subscribe({\n        next: scene => renderScene(ctx, scene),\n        complete: () => renderGameOver(ctx)\n      });\n    }\n\n  }\n\n  GameComponent.ɵfac = function GameComponent_Factory(t) {\n    return new (t || GameComponent)();\n  };\n\n  GameComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: GameComponent,\n    selectors: [[\"app-game\"]],\n    viewQuery: function GameComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.snakeDivTs = _t.first);\n      }\n    },\n    decls: 6,\n    vars: 1,\n    consts: [[\"id\", \"snake-content\", 1, \"main-content\", \"d-flex\", \"flex-column\", \"justify-content-center\", \"align-items-center\"], [\"snakeDiv\", \"\"], [\"routerLink\", \"/snake-new\", 1, \"btn\", \"btn-danger\", \"py-2\"], [1, \"text-center\"]],\n    template: function GameComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"button\", 2);\n        i0.ɵɵtext(3, \"Back\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"h1\", 3);\n        i0.ɵɵtext(5);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(5);\n        i0.ɵɵtextInterpolate1(\"Score: \", ctx.score, \"\");\n      }\n    },\n    directives: [i1.RouterLink],\n    styles: [\"\"]\n  });\n  return GameComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}