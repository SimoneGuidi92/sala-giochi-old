{"ast":null,"code":"// // import { log } from 'console';\n// // import { Observable, fromEvent } from 'rxjs';\n// import { map } from 'rxjs/operators';\n// import { map, filter, scan, switchMap, startWith, distinctUntilChanged, share, withLatestFrom, skip, tap, takeWhile } from 'rxjs/operators';\n// import { Observable, Subject, asapScheduler, pipe, of, from,\n//   interval, merge, fromEvent, BehaviorSubject, generate, combineLatest, animationFrame } from 'rxjs'\n// // import 'rxjs/Rx';\n// // import 'rxjs/add/operator/map';\n// import { DIRECTIONS, FPS, INITIAL_DIRECTION, POINTS_PER_APPLE, Point2D, SNAKE_LENGTH, SPEED, createCanvasElement } from 'src/assets/const-canvas/base-prop-func';\nimport { BehaviorSubject } from '../../../../assets/imports/rxjs';\nimport { DIRECTIONS, SPEED, SNAKE_LENGTH, FPS, POINTS_PER_APPLE } from '../../../../assets/imports/constants';\nimport { Key } from '../../../../assets/imports/types';\nimport { createCanvasElement, renderScene, renderGameOver } from '../../../../assets/imports/canvas';\nimport { isGameOver, nextDirection, move, eat, generateSnake, generateApples } from '../../../../assets/imports/utils';\nimport { distinctUntilChanged, filter, fromEvent, map, interval, scan, startWith, share, withLatestFrom, skip, tap, combineLatest, animationFrame, takeWhile } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let GameComponent = /*#__PURE__*/(() => {\n  class GameComponent {\n    constructor() {}\n\n    ngOnInit() {\n      // throw new Error('Method not implemented.');\n\n      /**\r\n      * Create canvas element and append it to the page\r\n      */\n      let canvas = createCanvasElement();\n      let ctx = canvas.getContext('2d');\n      document.body.appendChild(canvas);\n      /**\r\n       * Starting values\r\n       */\n\n      const INITIAL_DIRECTION = DIRECTIONS[Key.RIGHT];\n      /**\r\n       * Determines the speed of the snake\r\n       */\n\n      let ticks$ = interval(SPEED);\n      /**\r\n       * Track some general user interactions with the document\r\n       */\n\n      let click$ = fromEvent(document, 'click');\n      let keydown$ = fromEvent(document, 'keydown');\n      /**\r\n       * Change direction of the snake based on the latest arrow keypress by the user\r\n       */\n\n      let direction$ = keydown$.pipe(map(event => DIRECTIONS[event.keyCode]), filter(direction => !!direction), scan(nextDirection), startWith(INITIAL_DIRECTION), distinctUntilChanged());\n      /**\r\n       * Broadcasting mechanism used to notify subscribers of collisions\r\n       * between the snake and the apples\r\n       */\n\n      let length$ = new BehaviorSubject(SNAKE_LENGTH);\n      /**\r\n       * Accumulates the length of the snake (number of body segments)\r\n       */\n\n      let snakeLength$ = length$.pipe(scan((step, snakeLength) => snakeLength + step), share());\n      /**\r\n       * Player's score\r\n       */\n\n      let score$ = snakeLength$.pipe(startWith(0), scan((score, _) => score + POINTS_PER_APPLE));\n      /**\r\n       * Accumulates an array of body segments. Each segment is represented\r\n       * as a cell on the grid\r\n       */\n\n      let snake$ = ticks$.pipe(withLatestFrom(direction$, snakeLength$, (_, direction, snakeLength) => [direction, snakeLength]), scan(move, generateSnake()), share());\n      /**\r\n       * List of apples\r\n       */\n\n      let apples$ = snake$.pipe(scan(eat, generateApples()), distinctUntilChanged(), share());\n      /**\r\n       * Used to broadcast collisions to update the score and add a new\r\n       * body segment to the snake\r\n       */\n\n      let appleEaten$ = apples$.pipe(skip(1), tap(() => length$.next(POINTS_PER_APPLE))).subscribe();\n      /**\r\n       * Core game logic which returns an Observable of the scene. This will be\r\n       * used to render the game to the canvas as it unfolds\r\n       */\n\n      let scene$ = combineLatest(snake$, apples$, score$, (snake, apples, score) => ({\n        snake,\n        apples,\n        score\n      }));\n      /**\r\n       * This stream takes care of rendering the game while maintaining 60 FPS\r\n       */\n\n      let game$ = interval(1000 / FPS, animationFrame).pipe(withLatestFrom(scene$, (_, scene) => scene), takeWhile(scene => !isGameOver(scene))).subscribe({\n        next: scene => renderScene(ctx, scene),\n        complete: () => renderGameOver(ctx)\n      });\n    }\n\n  }\n\n  GameComponent.ɵfac = function GameComponent_Factory(t) {\n    return new (t || GameComponent)();\n  };\n\n  GameComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: GameComponent,\n    selectors: [[\"app-game\"]],\n    decls: 4,\n    vars: 0,\n    consts: [[1, \"game-container\"], [\"id\", \"snakeCanvas\", \"width\", \"500\", \"height\", \"500\"]],\n    template: function GameComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"p\");\n        i0.ɵɵtext(1, \"game works!\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(2, \"div\", 0);\n        i0.ɵɵelement(3, \"canvas\", 1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    styles: [\"\"]\n  });\n  return GameComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}